{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useEffect, useLayoutEffect, useState } from 'react';\nimport { addNotificationResponseReceivedListener } from './NotificationsEmitter';\nimport NotificationsEmitterModule from './NotificationsEmitterModule';\nimport { mapNotificationResponse } from './utils/mapNotificationResponse';\nexport default function useLastNotificationResponse() {\n  var _useState = useState(undefined),\n    _useState2 = _slicedToArray(_useState, 2),\n    lastNotificationResponse = _useState2[0],\n    setLastNotificationResponse = _useState2[1];\n  useLayoutEffect(function () {\n    var subscription = addNotificationResponseReceivedListener(function (response) {\n      var mappedResponse = mapNotificationResponse(response);\n      setLastNotificationResponse(mappedResponse);\n    });\n    return function () {\n      subscription.remove();\n    };\n  }, []);\n  useEffect(function () {\n    NotificationsEmitterModule.getLastNotificationResponseAsync == null ? void 0 : NotificationsEmitterModule.getLastNotificationResponseAsync().then(function (response) {\n      var mappedResponse = response ? mapNotificationResponse(response) : response;\n      setLastNotificationResponse(function (currentResponse) {\n        return currentResponse != null ? currentResponse : mappedResponse;\n      });\n    });\n  }, []);\n  return lastNotificationResponse;\n}","map":{"version":3,"names":["useEffect","useLayoutEffect","useState","addNotificationResponseReceivedListener","NotificationsEmitterModule","mapNotificationResponse","useLastNotificationResponse","_useState","undefined","_useState2","_slicedToArray","lastNotificationResponse","setLastNotificationResponse","subscription","response","mappedResponse","remove","getLastNotificationResponseAsync","then","currentResponse"],"sources":["D:\\practice\\projects\\meditationApp\\meditationApp\\homework-4-nisheshacharya\\homework4\\node_modules\\expo-notifications\\src\\useLastNotificationResponse.ts"],"sourcesContent":["import { useEffect, useLayoutEffect, useState } from 'react';\n\nimport { NotificationResponse } from './Notifications.types';\nimport { addNotificationResponseReceivedListener } from './NotificationsEmitter';\nimport NotificationsEmitterModule from './NotificationsEmitterModule';\nimport { mapNotificationResponse } from './utils/mapNotificationResponse';\n\n/**\n * A React hook always returns the notification response that was received most recently\n * (a notification response designates an interaction with a notification, such as tapping on it).\n *\n * > If you don't want to use a hook, you can use `Notifications.getLastNotificationResponseAsync()` instead.\n *\n * @return The hook may return one of these three types/values:\n * - `undefined` - until we're sure of what to return,\n * - `null` - if no notification response has been received yet,\n * - a [`NotificationResponse`](#notificationresponse) object - if a notification response was received.\n *\n * @example Responding to a notification tap by opening a URL that could be put into the notification's `data`\n * (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n * ```jsx\n * import * as Notifications from 'expo-notifications';\n * import { Linking } from 'react-native';\n *\n * export default function App() {\n *   const lastNotificationResponse = Notifications.useLastNotificationResponse();\n *   React.useEffect(() => {\n *     if (\n *       lastNotificationResponse &&\n *       lastNotificationResponse.notification.request.content.data.url &&\n *       lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n *     ) {\n *       Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n *     }\n *   }, [lastNotificationResponse]);\n *   return (\n *     // Your app content\n *   );\n * }\n * ```\n * @header listen\n */\nexport default function useLastNotificationResponse() {\n  const [lastNotificationResponse, setLastNotificationResponse] = useState<\n    NotificationResponse | null | undefined\n  >(undefined);\n\n  // useLayoutEffect ensures the listener is registered as soon as possible\n  useLayoutEffect(() => {\n    const subscription = addNotificationResponseReceivedListener((response) => {\n      const mappedResponse = mapNotificationResponse(response);\n      setLastNotificationResponse(mappedResponse);\n    });\n    return () => {\n      subscription.remove();\n    };\n  }, []);\n\n  // On each mount of this hook we fetch last notification response\n  // from the native module which is an \"always active listener\"\n  // and always returns the most recent response.\n  useEffect(() => {\n    NotificationsEmitterModule.getLastNotificationResponseAsync?.().then((response) => {\n      // We only update the state with the resolved value if it's empty,\n      // because if it's not empty it must have been populated by the `useLayoutEffect`\n      // listener which returns \"live\" values.\n      const mappedResponse = response ? mapNotificationResponse(response) : response;\n      setLastNotificationResponse((currentResponse) => currentResponse ?? mappedResponse);\n    });\n  }, []);\n\n  return lastNotificationResponse;\n}\n"],"mappings":";AAAA,SAASA,SAAS,EAAEC,eAAe,EAAEC,QAAQ,QAAQ,OAAO;AAG5D,SAASC,uCAAuC,QAAQ,wBAAwB;AAChF,OAAOC,0BAA0B,MAAM,8BAA8B;AACrE,SAASC,uBAAuB,QAAQ,iCAAiC;AAqCzE,eAAc,SAAUC,2BAA2BA,CAAA;EACjD,IAAAC,SAAA,GAAgEL,QAAQ,CAEtEM,SAAS,CAAC;IAAAC,UAAA,GAAAC,cAAA,CAAAH,SAAA;IAFLI,wBAAwB,GAAAF,UAAA;IAAEG,2BAA2B,GAAAH,UAAA;EAK5DR,eAAe,CAAC,YAAK;IACnB,IAAMY,YAAY,GAAGV,uCAAuC,CAAC,UAACW,QAAQ,EAAI;MACxE,IAAMC,cAAc,GAAGV,uBAAuB,CAACS,QAAQ,CAAC;MACxDF,2BAA2B,CAACG,cAAc,CAAC;IAC7C,CAAC,CAAC;IACF,OAAO,YAAK;MACVF,YAAY,CAACG,MAAM,EAAE;IACvB,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;EAKNhB,SAAS,CAAC,YAAK;IACbI,0BAA0B,CAACa,gCAAgC,oBAA3Db,0BAA0B,CAACa,gCAAgC,CAAE,CAAE,CAACC,IAAI,CAAC,UAACJ,QAAQ,EAAI;MAIhF,IAAMC,cAAc,GAAGD,QAAQ,GAAGT,uBAAuB,CAACS,QAAQ,CAAC,GAAGA,QAAQ;MAC9EF,2BAA2B,CAAC,UAACO,eAAe;QAAA,OAAKA,eAAe,WAAfA,eAAe,GAAIJ,cAAc;MAAA,EAAC;IACrF,CAAC,CAAC;EACJ,CAAC,EAAE,EAAE,CAAC;EAEN,OAAOJ,wBAAwB;AACjC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}